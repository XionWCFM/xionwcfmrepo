---
title: 프론트엔드 퍼널의 관리 방식과 트레이드 오프 , 그리고 Best Practice
description: 솔직히 베스트 프래티스는 없는 것 같기도...
thumbnail: fallback
categories: frontend
writeDate: 2024-07-23T08:29:07.053Z
releaseDate: 2024-07-23T14:32:00.053Z
canView: false
authority: public
---

웹뷰를 다루는 도메인에서 개발을 하면서 크고 작은 퍼널들을 다루어야 하는 일들이 많았습니다. 이렇게도 관리해보고 저렇게도 관리 해보았지만 거의 전부 하나씩은 아쉬운 점이 있었어요

그래서 오늘은 프론트엔드 퍼널의 관리 방식과 트레이드 오프, 그리고 지금 제가 생각하는 베스트 프래티스를 정리해보고자 합니다.


## 대표적인 퍼널의 관리 방식

**1. 인메모리 상태를 통해 관리하기**

가장 떠올리기 쉽고 가장 쉽게 구현할 수 있는 방법 중 하나입니다. 순수하게 리액트에만 의존한다는 점도 좋은 포인트 중 하나라고 생각해요

```tsx

const [funnel,setFunnel] = useState('page-1')
return (
    <div>
        {funnel === 'page-1' && <Page1 />}
        {funnel === 'page-2' && <Page2 />}
        {funnel === 'page-3' && <Page3 />}
    </div>
)
```

**2. 외부 상태와 연동하여 관리하기**

이 경우는 로컬스토리지, 세션스토리지 등의 외부 스토리지를 이용하여 구현할 수 있을 것입니다.

**3. 쿼리스트링을 통해 관리하기**

Toss의 [퍼널: 쏟아지는 페이지 한 방에 관리하기](https://www.youtube.com/watch?v=NwLWX2RNVcw)라는 영상을 통해 대중적으로 알려진 방식입니다.

**4. routing을 통해 관리하기**

앞선 방법들이 하나의 페이지에서 여러 퍼널을 관리하는 방법이었다면, 이 방법은 페이지 자체를 퍼널로 관리하는 방법입니다.



## 각 퍼널 구현 방식의 장단점

### 상태를 통한 관리


```
장점
- 퍼널과 관련된 까다로운 요구사항, 정책을 구현 해야 하는 경우 유용함
- 테스트하기 쉬움
- 상태관리에 대한 고민을 적게 가져갈 수 있다.
```

```
단점
- 뒤로가기, 앞으로가기 등의 액션을 통해 퍼널 상태를 변경하는 것이 어려움
- 모바일 기기 사용자의 경우 뒤로가기, 앞으로가기 제스처를 통한 퍼널 이동이 어려움
- 새로고침, 페이지 이탈 후 재진입 시 퍼널에 입력한 내용이 초기화 되어버림
- 단일 페이지에 퍼널이 많아지는 경우 해당 페이지의 번들 사이즈가 과도하게 커질 수 있다.
```

상태를 통해 관리하는 것의 최대 장점은 특정 조건이 만족 되었을 때 특정 퍼널로의 이동을 막는 것이나 특정 퍼널에 악의적으로 접근하는 행동 등을 거의 완벽히 차단할 수 있다는 것을 들 수 있을 것 같습니다.

정책상 매우 중요한 퍼널의 경우 상태로 구현하는 것이 유용할 수 있었습니다.


### 외부 스토리지와 연동하여 관리

```
장점
- 새로고침, 페이지 이탈 등의 사용자 액션에도 상태를 유지할 수 있다.
```

```
단점
- 외부 스토리지에 대한 관리 책임이 생겨난다.
```

외부 스토리지를 이용하는 방식은 상태를 통한 방식과 장단점을 거의 공유합니다. 그러나 상태를 통한 관리의 약점이었던 새로고침, 페이지 이탈 등에 대응할 수 있으며 구현에 따라 퍼널을 어디까지 진행하였는지 기억하고 중간 지점부터 퍼널을 시작하게 하는 것도 가능할 것입니다.


## 쿼리스트링을 이용하여 관리

```
장점
- 브라우저에 직접 히스토리스택을 쌓기 때문에 앞으로가기 ,뒤로가기 등의 액션에 대응할 수 있다.
```

```
단점
- 브라우저에 직접 히스토리스택을 쌓기 때문에 다시 접근해서는 안되는 퍼널에 대한 처리 등이 어려울 수 있다.
- 쿼리스트링을 통해 사용자가 치팅을 시도할 수 있다.
```

쿼리스트링을 이용한 방식은 트레이드오프가 명확한 것 같습니다.

특히 브라우저 히스토리 스택은 정책상 인위적으로 비우는 행동이 제한된다는 점에서 더욱 단점이 치명적이게 느껴지는 상황도 존재했습니다.



## routing을 이용하여 관리

```
장점
- 브라우저에 직접 히스토리스택을 쌓기 때문에 앞으로가기 ,뒤로가기 등의 액션에 대응할 수 있다.
- 쿼리스트링을 이용한 방식 대비 가드가 필요한 퍼널에 대한 동작을 상대적으로 자연스럽게 구현 가능하다.
- 페이지를 분리하여 구현하기 때문에 한 페이지의 번들 사이즈에 대한 문제는 적어진다.
```

```
단점
- 퍼널의 시작과 끝이 멀리 떨어지게되어 퍼널 흐름 파악이 어려울 수 있다.
- 페이지가 늘어나게 되는 만큼 next.js 등의 도구를 이용할 때 빌드 시간이 길어질 수 있다.
- 여러 페이지 간의 데이터 전달에 대한 문제가 생겨난다. (어떻게 상태를 전달하고 취합할 것인가?)
```

routing을 이용한 방식은 쿼리스트링을 이용한 방식과 매우 유사한 특징을 가지고 있습니다.

그러나 routing을 이용하는 경우에는 여러 페이지를 관통하는 데이터 전달 방식에 대한 고민이 생겨난다는 점이 중요하다고 할 수 있을 것 같습니다.

